---
layout: post
title: "Maven 笔记"
date: 2018-01-10
tag: Maven 
--- 

## Maven 概念

Maven 作为一个构建工具，不仅能帮我们自动化构建，还能够抽象构建过程，提供构建任务实现; 它跨平台，对外提供了一致的操作接口，这一切足以使它成为优秀的、流行的构建工具。

Maven 不仅是构建工具，还是一个依赖管理工具和项目管理工具，它提供了中央仓库，能帮我自动下载构件。

## maven 的安装

一：因为本人是 window 系统，所以这里只介绍 window 下如何安装，在安装 Maven 之前，先确认已经安装了 JDK.

![](https://user-gold-cdn.xitu.io/2018/1/2/160b27fca26bcd84?imageView2/0/w/1280/h/960/ignore-error/1)

二：接着去 [Maven 官网](https://link.juejin.im?target=http%3A%2F%2Fmaven.apache.org%2Fdownload.cgi)下载界面下载想要的版本解压到你想要的目录就行

![](https://user-gold-cdn.xitu.io/2018/1/2/160b27fca6e67627?imageView2/0/w/1280/h/960/ignore-error/1)![](https://user-gold-cdn.xitu.io/2018/1/2/160b27fca695c1a9?imageView2/0/w/1280/h/960/ignore-error/1)

三：最后设置一下环境变量，将 Maven 安装配置到操作系统环境中，主要就是配置 **M2_HOME **和** PATH** 两项，如图

![](https://user-gold-cdn.xitu.io/2018/1/2/160b27fca6d81655?imageView2/0/w/1280/h/960/ignore-error/1)

都搞定后，验证一下，打开 doc 输入 mvn -v 如何得到下面信息就说明配置成功了

![](https://user-gold-cdn.xitu.io/2018/1/2/160b27fca9ef3782?imageView2/0/w/1280/h/960/ignore-error/1)

## maven 目录

![](https://user-gold-cdn.xitu.io/2018/1/2/160b27fce5e78f24?imageView2/0/w/1280/h/960/ignore-error/1)

*   **bin 目录**： 该目录包含了 mvn 运行的脚本，这些脚本用来配置 java 命令，准备好 classpath 和相关的 Java 系统属性，然后执行 Java 命令。
*   **boot 目录**:  该目录只包含一个文件，该文件为 plexus-classworlds-2.5.2.jar。plexus-classworlds 是一个类加载器框架，相对于默认的 java 类加载器，它提供了更加丰富的语法以方便配置，Maven 使用该框架加载自己的类库。
*   **conf 目录**: 该目录包含了一个非常重要的文件 settings.xml。直接修改该文件，就能在机器上全局地定制 Maven 的行为，一般情况下，我们更偏向于复制该文件至~/.m2 / 目录下（~ 表示用户目录），然后修改该文件，在用户范围定制 Maven 的行为。
*   **lib 目录**: 该目录包含了所有 Maven 运行时需要的 Java 类库，Maven 本身是分模块开发的，因此用户能看到诸如 maven-core-3.0.jar、maven-model-3.0.jar 之类的文件，此外这里还包含一些 Maven 用到的第三方依赖如 commons-cli-1.2.jar、commons-lang-2.6.jar 等等。

## Maven 常用命令说明

**mvn clean**  表示运行清理操作（会默认把 target 文件夹中的数据清理）。

**mvn clean compile**  表示先运行清理之后运行编译，会将代码编译到 target 文件夹中。 

**mvn clean test**  运行清理和测试。

**mvn clean package**  运行清理和打包。

**mvn clean install**  运行清理和安装，会将打好的包安装到本地仓库中，以便其他的项目可以调用。 

**mvn clean deploy**  运行清理和发布（发布到私服上面）。

上面的命令大部分都是连写的，大家也可以拆分分别执行，这是活的，看个人喜好以及使用需求，Eclipse Run as 对 maven 项目会提供常用的命令。

## 设置 conf 目录下的 setting.xml
```xml
<!--本地仓库目录-->
<localRepository>D:/IntelliJProjects/apache-maven-3.5.3/LocalRepository</localRepository>

<!--镜像-->
<mirrors>
 <mirror> 
    <id>alimaven</id> 
    <name>aliyun maven</name> 
    <url>http://maven.aliyun.com/nexus/content/groups/public/</url> 
    <mirrorOf>central</mirrorOf> 
  </mirror> 
</mirrors>
```

## Maven 插件安装，基于 IDEA

博主现在使用 IDEA 来开发的，所以这里介绍一下 IDEA 中如何配置引入我们上面下载好的 Maven

![](https://user-gold-cdn.xitu.io/2018/1/2/160b27fceda7382f?imageView2/0/w/1280/h/960/ignore-error/1)

## Maven 使用

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.tengj</groupId>
    <artifactId>springBootDemo1</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>war</packaging>
    <name>springBootDemo1</name>
</project>
```

代码的第一行是 XML 头，指定了该 xml 文档的版本和编码方式。 

project 是所有 pom.xml 的根元素，它还声明了一些 POM 相关的命名空间及 xsd 元素。 根元素下的第一个子元素 modelVersion 指定了当前的 POM 模型的版本，对于 Maven3 来说，它只能是 4.0.0 代码中最重要是包含了 groupId,artifactId 和 version 了。这三个元素定义了一个项目基本的坐标，在 Maven 的世界，任何的 jar、pom 或者 jar 都是以基于这些基本的坐标进行区分的。

groupId 定义了项目属于哪个组，随意命名，比如谷歌公司的 myapp 项目，就取名为 com.google.myapp

artifactId 定义了当前 Maven 项目在组中唯一的 ID, 比如定义 hello-world。

version 指定了项目当前的版本 0.0.1-SNAPSHOT,SNAPSHOT 意为快照，说明该项目还处于开发中，是不稳定的。

packaging 项目的打包类型，即作为项目的发布形式，其可能的类型。在Maven 3中，其可用的打包类型如下：jar（默认类型）war 等等

name 元素生命了一个对于用户更为友好的项目名称，虽然这不是必须的，但还是推荐为每个 POM 声明 name, 以方便信息交流

## 依赖的配置

```xml
<project>
...
<dependencies>
    <dependency>
        <groupId>实际项目</groupId>
        <artifactId>模块</artifactId>
        <version>版本</version>
        <type>依赖类型</type>
        <scope>依赖范围</scope>
        <optional>依赖是否可选</optional>
        <!--例子-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.6</version>
            <scope>test</scope>
        </dependency>

        
        <!--主要用于排除传递性依赖-->
        <exclusions>
            <exclusion>
                <groupId>…</groupId>
                <artifactId>…</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
<dependencies>
...
</project>
```

根元素 project 下的 dependencies 可以包含一个或者多个 dependency 元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素有：

*   **grounpId、artifactId 和 version**: 以来的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven 根据坐标才能找到需要的依赖。
*   **type**: 依赖的类型，对于项目坐标定义的 packaging。大部分情况下，该元素不必声明，其默认值为 jar
*   **scope**: 依赖的范围
*   **optional**: 标记依赖是否可选
*   **exclusions**: 用来排除传递性依赖

## 依赖范围

依赖范围就是用来控制依赖和三种 classpath(编译 classpath，测试 classpath、运行 classpath) 的关系，Maven 有如下几种依赖范围：

*   **compile:** 编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的 Maven 依赖，对于编译、测试、运行三种 classpath 都有效。典型的例子是 spring-code, 在编译、测试和运行的时候都需要使用该依赖。
*   **test:** 测试依赖范围。使用次依赖范围的 Maven 依赖，只对于测试 classpath 有效，在编译主代码或者运行项目的使用时将无法使用此依赖。典型的例子是 Jnuit, 它只有在编译测试代码及运行测试的时候才需要。
*   **provided:** 已提供依赖范围。使用此依赖范围的 Maven 依赖，对于编译和测试 classpath 有效，但在运行时候无效。典型的例子是 servlet-api, 编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器以及提供，就不需要 Maven 重复地引入一遍。
*   **runtime:** 运行时依赖范围。使用此依赖范围的 Maven 依赖，对于测试和运行 classpath 有效，但在编译主代码时无效。典型的例子是 JDBC 驱动实现，项目主代码的编译只需要 JDK 提供的 JDBC 接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体 JDBC 驱动。
*   **system:** 系统依赖范围。该依赖与三种 classpath 的关系，和 provided 依赖范围完全一致，但是，使用 system 范围的依赖时必须通过 systemPath 元素显示地指定依赖文件的路径。由于此类依赖不是通过 Maven 仓库解析的，而且往往与本机系统绑定，可能构成构建的不可移植，因此应该谨慎使用。systemPath 元素可以引用环境变量，如：

```xml
<dependency>
    <groupId>javax.sql</groupId>
    <artifactId>jdbc-stdext</artifactId>
    <Version>2.0</Version>
    <scope>system</scope>
    <systemPath>${java.home}/lib/rt.jar</systemPath>
</dependency>
```

*   **import:** 导入依赖范围。该依赖范围不会对三种 classpath 产生实际的影响。 上述除 import 以外的各种依赖范围与三种 classpath 的关系如下:

![](https://user-gold-cdn.xitu.io/2018/1/2/160b27fceaaf09e1?imageView2/0/w/1280/h/960/ignore-error/1)

## 传递性依赖

比如一个 account-email 项目为例，account-email 有一个 compile 范围的 spring-code 依赖，spring-code 有一个 compile 范围的 commons-logging 依赖，那么 commons-logging 就会成为 account-email 的 compile 的范围依赖，commons-logging 是 account-email 的一个传递性依赖

![](https://user-gold-cdn.xitu.io/2018/1/2/160b27fcea58b801?imageView2/0/w/1280/h/960/ignore-error/1)

有了传递性依赖机制，在使用 Spring Framework 的时候就不用去考虑它依赖了什么，也不用担心引入多余的依赖。Maven 会解析各个直接依赖的 POM，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。

## 依赖范围

假设 A 依赖于 B,B 依赖于 C，我们说 A 对于 B 是第一直接依赖，B 对于 C 是第二直接依赖，A 对于 C 是传递性依赖。第一直接依赖和第二直接依赖的范围决定了传递性依赖的范围，如下图所示，最左边一行表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间的交叉单元格则表示传递依赖范围。

![](https://user-gold-cdn.xitu.io/2018/1/2/160b27fceba81e2b?imageView2/0/w/1280/h/960/ignore-error/1)

从上图中，我们可以发现这样的规律：

*   当第二直接依赖的范围是 compile 的时候，传递性依赖的范围与第一直接依赖的范围一致；
*   当第二直接依赖的范围是 test 的时候，依赖不会得以传递；
*   当第二直接依赖的范围是 provided 的时候，只传递第一直接依赖范围也为 provided 的依赖，切传递依赖的范围同样为 provided;
*   当第二直接依赖的范围是 runtime 的时候，传递性依赖的范围与第一直接依赖的范围一致，但 compile 列外，此时传递性依赖范围为 runtime.

## 依赖调解 

有时候，当传递性依赖造成为题的时候，就需要清楚地知道该传递性依赖是从哪条依赖路径引入的。这就是依赖调解的作用，依赖调解有两大原则： 1. 路径最近者优先 比如项目有 A 有这样的依赖关系：A->B->C->X(1.0)、A->D->X(2.0),X 是 A 的传递性依赖，但是两条依赖路径上有两个版本的 X，所以根据第一原则，A->D->X(2.0) 路径短，所以 X(2.0) 会被解析使用 2. 第一声明者优先 如果路径都一样长的话，第一原则就不行了，比如 A->B->Y(1.0)、A->C->Y(2.0),Y(1.0) 和 Y(2.0) 的路径一样，所以这时候根据第二原则，先声明的被解析。

## 可选依赖

![](https://user-gold-cdn.xitu.io/2018/1/2/160b27fcf227ae4b?imageView2/0/w/1280/h/960/ignore-error/1)

如图，项目中 A 依赖 B，B 依赖于 X 和 Y，如果所有这三个的范围都是 compile 的话，那么 X 和 Y 就是 A 的 compile 范围的传递性依赖，但是如果我想 X,Y 不作为 A 的传递性依赖，不给他用的话。就需要下面提到的配置可选依赖。

```xml
<project>  
    <modelVersion>4.0.0</modelVersion>  
    <groupId>com.juvenxu.mvnbook</groupId>  
    <artifactId>project-b</artifactId>  
    <version>1.0.0</version>  
    <dependencies>  
        <dependency>  
            <groupId>mysql</groupId>  
            <artifactId>mysql-connector-java</artifactId>  
            <version>5.1.10</version>  
            <optional>true</optional>  
        </dependency>  
        <dependency>  
            <groupId>postgresql</groupId>  
            <artifactId>postgresql</groupId>  
            <version>8.4-701.jdbc3</version>  
            <optional>true</optional>  
        </dependency>  
    </dependencies>  
</project>  
```

配置也简单，在依赖里面添加

```xml
<optional>true</optional>
```

就表示可选依赖了，这样 A 如果想用 X,Y 就要直接显示的添加依赖了。

## 排除依赖

有时候你引入的依赖中包含你不想要的依赖包，你想引入自己想要的，这时候就要用到排除依赖了，比如下图中 spring-boot-starter-web 自带了 logback 这个日志包，我想引入 log4j2 的，所以我先排除掉 logback 的依赖包，再引入想要的包就行了

![](https://user-gold-cdn.xitu.io/2018/1/2/160b27fd18cdd481?imageView2/0/w/1280/h/960/ignore-error/1)

排除依赖代码结构：

```xml
<exclusions>
    <exclusion>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-logging</artifactId>
    </exclusion>
</exclusions>
```

这里注意：声明 exclustion 的时候只需要 groupId 和 artifactId，而不需要 version 元素，这是因为只需要 groupId 和 artifactId 就能唯一定位依赖图中的某个依赖。

## 归类依赖

有时候我们引入的很多依赖包，他们都来自同一个项目的不同模块，所以他们的版本号都一样，这时候我们可以用属性来统一管理版本号

```xml
<project>  
    <modelVersion>4.0.0</modelVersion>  
    <groupId>com.juven.mvnbook.account</groupId>  
    <artifactId>accout-email</artifactId>  
    <version>1.0.0-SNAPSHOT</version>  
    <properties>  
        <springframework.version>1.5.6</springframework.version>  
    </properties>  
    <dependencies>  
        <dependency>  
            <groupId>org.springframework</groupId>  
            <artifactId>spring-core</artifactId>  
            <version>${springframework.version}</version>  
        </dependency>   
        <dependency>  
            <groupId>org.springframework</groupId>  
            <artifactId>spring-beans</artifactId>  
            <version>${springframework.version}</version>  
        </dependency>         
    </dependencies>  
</project>  
```

如图所示，先通过

```xml
</properties>
    这里定义你先要的版本
</properties>
```

来定义，然后在下面依赖使用 ${} 来引入你的属性。

