---
layout: post
title: "Java 常用的八种排序算法与代码实现"
date: 2017-11-1 
tag: 排序算法 
--- 
<br>

1. [冒泡排序](#冒泡排序)
2. [简单选择排序](#简单选择排序)
3. [直接插入排序](#直接插入排序)
4. [希尔排序](#希尔排序)
5. [堆排序](#堆排序)
6. [归并排序](#归并排序)
7. [快速排序](#快速排序)
8. [基数排序](#基数排序)
9. [总结](#总结)

# 冒泡排序

> 一般不用

1.  两两比较，如果后者比前者大则交换位置
2.  每遍历一圈最大的数就会冒到最后，则确定了本轮比较中的最大值放到最后不动
3.  循环 1、2 直至遍历完所有

    ![](https://upload-images.jianshu.io/upload_images/1441907-d56533b75c693313.png)


```java
/**
 * 冒泡排序
 */
private static int[] bubbleSort(int[] a)
{
    // 数组长度，将这个提取出来是为了提高速度
    int length = a.length;
    int temp;
    // i 控制外循环即总共需要将多少个数字进行排序，j 控制内循环即每次循环都会将最大的数排到右边
    for (int i = 0; i < length; i++)
    {
        for (int j = 0; j < length - i - 1; j++)
        {
            // 如果前面的数字大于后面的数字就将前面的数字和后面的数字进行交换，直接最大的数字被排到最右侧
            // 最大的数不再进行比较，所以是 (j < length - i - 1)
            if (a[j] > a[j + 1])
            {
                temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
    return a;
}
```

# 简单选择排序

> 常用于取序列中最大最小的几个数时

(如果每次比较都交换，那么就是交换排序；如果每次比较完一个循环再交换，就是简单选择排序。)

1.  遍历整个序列，将最小的数放在最前面。
2.  遍历剩下的序列，将最小的数放在最前面。
3.  重复第二步，直到只剩下一个数。

    ![](https://upload-images.jianshu.io/upload_images/1441907-4d52b967174d8003.png)

如何写成代码：

1.  首先确定循环次数，并且记住当前数字和当前位置。
2.  将当前位置后面所有的数与当前数字进行对比，小数赋值给 min，并记住小数的位置。
3.  比对完成后，将最小的值与第一个数的值交换。
4.  重复 2、3 步。

代码实现如下：

```java
/**
 * 简单选择排序
 */
private static int[] simpleSelectSort(int[] a)
{
    int length = a.length;
    // 循环次数
    for (int i = 0; i < length - 1; i++)
    {
        int min = a[i];
        int position = i;
        // 选出最小的值和位置
        for (int j = i + 1; j < length; j++)
        {
            if (a[j] < min)
            {
                min = a[j];
                position = j;
            }
        }
        // 交换位置
        a[position] = a[i];
        // 将最小的放到前面
        a[i] = min;
    }
    return a;
}
```

# 直接插入排序

> 经常碰到这样一类排序问题：把新的数据插入到已经排好的数据列中

1.  将第一个数和第二个数排序，然后构成一个有序序列
2.  将第三个数插入进去，构成一个新的有序序列。
3.  对第四个数、第五个数…… 直到最后一个数，重复第二步。

    ![](https://upload-images.jianshu.io/upload_images/1441907-5b0cb554db41f153.png)

如何写写成代码：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到下一位置中
6. 重复步骤2 ~ 5

代码实现如下：

```java
/**
 * 直接插入排序
 */
private static int[] insertSort(int[] a)
{
    for (int i = 1; i < a.length; i++)
    {
        for (int j = i; j > 0; j--)
        {
            // 取出下一个元素，在已经排序的元素序列中从后向前扫描
            // 如果新元素小于已经排序的元素，互换
            if (a[j] < a[j - 1])
            {
                int temp = a[j];
                a[j] = a[j - 1];
                a[j - 1] = temp;
            } else
            {
                break;
            }
        }
    }
    return a;
}
```

# 希尔排序

> 对于直接插入排序问题，数据量巨大时

1.  将数的个数设为 n，取奇数 k = n/2，将下标差值为 k 的书分为一组，构成有序序列。
2.  再取 k = k/2 ，将下标差值为 k 的书分为一组，构成有序序列。
3.  重复第二步，直到 k = 1 执行简单插入排序。

    ![](https://upload-images.jianshu.io/upload_images/1441907-5db88083f6d1df10.png)

如何写成代码：

1.  首先确定分的组数。
2.  然后对组中元素进行插入排序。
3.  然后将 length/2，重复 1,2 步，直到 length=0 为止。

代码实现如下：

```java
/**
 * 希尔排序
 */
private static int[] shellSort(int[] a)
{
    int d = a.length;
    while (d != 0)
    {
        d = d / 2;
        // 分的组数
        for (int x = 0; x < d; x++)
        {
            // 组中的元素，从第二个数开始
            for (int i = x + d; i < a.length; i = i + d)
            {
                // j为有序序列最后一位的位数
                int j = i - d;
                // 要插入的元素
                int temp = a[i];
                // 从后往前遍历。
                for (; j >= 0 && temp < a[j]; j = j - d)
                {
                    // 向后移动d位
                    a[j + d] = a[j];
                }
                a[j + d] = temp;
            }
        }
    }
    return a;
}
```

# 堆排序

> 对简单选择排序的优化

1.  将数组构建成大堆二叉树，即所有节点的父节点的值都大于或等于叶子节点的完全二叉树
2.  将根节点与最后一个节点交换，然后断开最后一个节点。
3.  重复第一、二步，直到所有节点断开。

    ![](https://upload-images.jianshu.io/upload_images/1441907-5d38642fbb7ae3e4.png)

代码实现如下：

```java
/**
 * 堆排序
 */
private static void heapSort(int[] a)
{
    System.out.println("开始排序");
    int arrayLength = a.length;
    // 循环建堆
    for (int i = 0; i < arrayLength - 1; i++)
    {
        // 建堆
        buildMaxHeap(a, arrayLength - 1 - i);
        // 交换堆顶和最后一个元素
        swap(a, 0, arrayLength - 1 - i);
        System.out.println(Arrays.toString(a));
    }
}

private static void swap(int[] data, int i, int j)
{
    int tmp = data[i];
    data[i] = data[j];
    data[j] = tmp;
}

/**
 * 对 data 数组从 0 到 lastIndex 建大顶堆
 */
private static void buildMaxHeap(int[] data, int lastIndex)
{
    // 从 lastIndex 处节点（最后一个节点）的父节点开始
    for (int i = (lastIndex - 1) / 2; i >= 0; i--)
    {
        // k 保存正在判断的节点
        int k = i;
        // 如果当前 k 节点的子节点存在
        while (k * 2 + 1 <= lastIndex)
        {
            // k 节点的左子节点的索引
            int biggerIndex = 2 * k + 1;
            // 如果 biggerIndex 小于 lastIndex，即 biggerIndex + 1 代表的 k 节点的右子节点存在
            if (biggerIndex < lastIndex)
            {
                // 若果右子节点的值较大
                if (data[biggerIndex] < data[biggerIndex + 1])
                {
                    // biggerIndex 总是记录较大子节点的索引
                    biggerIndex++;
                }
            }
            // 如果 k 节点的值小于其较大的子节点的值
            if (data[k] < data[biggerIndex])
            {
                // 交换他们
                swap(data, k, biggerIndex);
                // 将 biggerIndex 赋予 k，开始 while 循环的下一次循环，重新保证 k 节点的值大于其左右子节点的值
                k = biggerIndex;
            } else
            {
                break;
            }
        }
    }
}
```

# 归并排序

> 速度仅次于快排，内存少的时候使用，可以进行并行计算的时候使用

1.  选择相邻两个数组成一个有序序列。
2.  选择相邻的两个有序序列组成一个有序序列。
3.  重复第二步，直到全部组成一个有序序列。

    ![](https://upload-images.jianshu.io/upload_images/1441907-a95693cd7caa1003.png)

代码实现如下：

```java
/**
 * 归并排序
 * 
 * @param a    待排序的数组
 * @param low  数组第一个数下标
 * @param high 数组最后一个数下标
 * @return 排好序的数组
 */
private static int[] sort(int[] a, int low, int high)
{
    int mid = (low + high) / 2;
    if (low < high)
    {
        // 递归排序左边
        sort(a, low, mid);
        // 递归排序右边
        sort(a, mid + 1, high);
        // 左右归并
        merge(a, low, mid, high);
    }
    return a;
}

private static void merge(int[] a, int low, int mid, int high)
{
    int[] temp = new int[high - low + 1];
    int i = low;
    int j = mid + 1;
    int k = 0;
    // 把较小的数先移到新数组中
    while (i <= mid && j <= high)
    {
        if (a[i] < a[j])
        {
            temp[k++] = a[i++];
        } else
        {
            temp[k++] = a[j++];
        }
    }
    // 把左边剩余的数移入数组
    while (i <= mid)
    {
        temp[k++] = a[i++];
    }
    // 把右边边剩余的数移入数组
    while (j <= high)
    {
        temp[k++] = a[j++];
    }
    // 把新数组中的数覆盖nums数组
    for (int x = 0; x < temp.length; x++)
    {
        a[x + low] = temp[x];
    }
}
```

# 快速排序

> 要求时间最快时

1. 先从数列中取出一个数作为基准数

2. 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边

3. 再对左右区间重复第二步，直到各区间只有一个数

    ![](https://upload-images.jianshu.io/upload_images/1441907-18a7e476e0ccaa17.png)

代码实现如下：

```java
/**
 * 快速排序
 * @param a    待排序的数组
 * @param low  数组第一个数下标
 * @param high 数组最后一个数下标
 * @return 排好序的数组
 */
private static int[] quickSort(int[] a, int low, int high)
{
    if (low < high)
    {
        // 选定的基准值（第一个数值作为基准值）
        int base = a[low];
        int i = low, j = high;
        while (i < j)
        {
            // 从右往左直到找到比基数小的值才停止循环
            while (i < j && a[j] > base)
            {
                j--;
            }
            if (i < j)
            {
                // 比基数小的值交换到 i 的位置
                a[i] = a[j];
                // 交换后，要从左往右找，即 i 位置的下一个位置开始
                i++;
            }
            // 从左往右直到找到比基数大的值才停止循环
            while (i < j && a[i] < base)
            {
                i++;
            }
            if (i < j)
            {
                // 比基数大的值交换到 j 的位置
                a[j] = a[i];
                // 交换后，要从右往左找，即 j 位置的上一个位置开始
                j--;
            }

        }

        // 当 i >= j 时，停止查找，此时将基数放入 a[i]
        // 这样 a[i] 基数左边的值都比他小，右边的值都比他大
        a[i] = base;
        quickSort(a, low, i - 1);
        quickSort(a, i + 1, high);
    }
    return a;
}
```

# 基数排序

> 用于大量数，很长的数进行排序时

1.  将所有的数的个位数取出，按照个位数进行排序，构成一个序列。
2.  将新构成的所有的数的十位数取出，按照十位数进行排序，构成一个序列。

    ![](https://upload-images.jianshu.io/upload_images/1441907-4dce4622538ceeff.png)

代码实现如下：

```java
/**
 * 基数排序
 */
private static int[] radixSort(int[] a)
{
    int digit = 0;// 数组的最大位数
    for (int i : a)
    {
        // 获取数组中数的最大位数
        digit = Math.max(digit, String.valueOf(i).length());
    }
    int k = 0;// 用户记录排序数组的索引
    int m = 1;// 当前的位数，个位用1表示，十位用2表示，以此类推
    int n = 1;// 用来表示当前位数的整数倍
    int type = 10;// 将余数从0-9分为10种类型
    int[][] temp = new int[type][a.length];// 第一维用来存储余数，第二维用来存储余数对应的数组值
    int[] order = new int[type];// 用户第二维数组值得索引计数
    while (m <= digit)
    {
        // 遍历数组中的每个元素，以当前位数依据余数进行归类
        for (int i = 0; i < a.length; i++)
        {
            int r = (a[i] / n) % 10;// 当前数值在当前位数的余数
            temp[r][order[r]] = a[i];// 第一次为temp[r][0],第二次为temp[r][1]......
            order[r]++;
        }
        // 遍历二维数组的第一维
        for (int i = 0; i < type; i++)
        {
            if (order[i] != 0)
            {// 当order[i]==0时，说明order[r]++没有执行，temp[r][]中没有存储数组值
                // 遍历二维数组的第二维
                for (int j = 0; j < order[i]; j++)
                {// order[i]表示当前i余数的类型存储的数组值的个数
                    a[k] = temp[i][j];
                    k++;
                }
            }
            order[i] = 0;
        }
        k = 0;// 排序数组索引初始化
        m++;// 当前位数个数的索引
        n *= 10;// 当前位数向前推
    }
    return a;
}
```

# 总结

| 排序方法 | 平均情况 | 最好情况 | 最坏情况 | 辅助空间 | 稳定性 |
| --- | --- | --- | --- | --- | --- |
| 冒泡排序 | O(n<sup>2</sup>) | O(n) | O(n<sup>2</sup>) | O(1) | 稳定 |
| 简单选择排序 | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(1) | 稳定 |
| 直接插入排序 | O(n<sup>2</sup>) | O(n) | O(n<sup>2</sup>) | O(1) | 稳定 |
| 希尔排序 | O(nlogn)~O(n<sup>2</sup>) | O(n<sup>1.3</sup>) | O(n<sup>2</sup>) | O(1) | 不稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | 不稳定 |
| 归并排序 | O(nlogn) | O(nlogn) | O(nlogn)) | O(n) | 稳定 |
| 快速排序 | O(nlogn) | O(nlogn) | O(n<sup>2</sup>) | O(logn)~O(n) | 不稳定 |
| 基数排序 | O(d(n + r)) | O(d(n + r)) | O(d(n + r)) | O(n + r) | 稳定 |

ps：基数排序时间复杂度中 r 代表基数，即示例代码中分配 r = 10 个桶，d 代表位数


