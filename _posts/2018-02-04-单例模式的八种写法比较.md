---
layout: post
title: "单例模式的八种写法比较"
date: 2018-02-04
tag: 单例模式
---   


# 单例模式的八种写法比较

## 单例模式的意义

单例模式是最简单的设计模式之一，属于创建型模式，它提供了一种创建对象的方式，确保只有单个对象被创建。这个设计模式主要目的是想在整个系统中只能出现类的一个实例，即一个类只有一个对象。
单例模式的解决的痛点就是节约资源，节省时间从两个方面看:

1. 由于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级的对象而言，是很重要的.
2. 因为不需要频繁创建对象，我们的GC压力也减轻了，而在GC中会有STW(stop the world)，从这一方面也节约了GC的时间
单例模式的缺点：简单的单例模式设计开发都比较简单，但是复杂的单例模式需要考虑线程安全等并发问题，引入了部分复杂度。


## 基本的实现思路

单例模式要求类能够有返回对象一个引用 (永远是同一个) 和一个获得该实例的方法（必须是静态方法，通常使用 getInstance 这个名称）。

单例的实现主要是通过以下两个步骤：

1.  将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；
2.  在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。

## 注意事项

单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁 (虽然这样会降低效率)。

## 单例模式的八种写法

### 1、饿汉式（静态常量）[可用]

```java
public class Singleton {

    private static Singleton instance = new Singleton();

    private Singleton(){}

    public static Singleton getInstance(){
        return instance;
    }
}

// 访问方式
// Singleton instance = Singleton.getInstance();
```


优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。

缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading(懒加载) 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。

### 2、饿汉式（静态代码块）[可用]

```java
public class Singleton {

    private static Singleton instance;

    static {
        instance = new Singleton();
    }

    private Singleton() {}

    public Singleton getInstance() {
        return instance;
    }
}
```

这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。

### 3、懒汉式 (线程不安全)[不可用]

```java
public class Singleton {

    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```


这种写法起到了 Lazy Loading 的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了 if (singleton == null) 判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。

### 4、懒汉式 (线程安全，同步方法)[不推荐用]

```java
public class Singleton {

    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```


解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对 getInstance() 方法进行了线程同步。

缺点：效率太低了，每个线程在想获得类的实例时候，执行 getInstance() 方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低要改进。

### 5、懒汉式 (线程不安全，同步代码块)[不可用]

```java
public class Singleton {

    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                instance = new Singleton();
            }
        }
        return instance;
    }
}
```


由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第 3 种实现方式遇到的情形一致，假如一个线程进入了 if (singleton == null) 判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。

### 6、懒汉式双重校验锁 [推荐用]

```java
public class Singleton {

    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```


Double-Check 概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次 if (singleton == null) 检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象。

优点：线程安全；延迟加载；效率较高。

扩展:
为什么需要 volatile？volatile 有什么用？

- (为什么) volatile 修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。（具有可见性）
- (有什么用)没有原子性：防止 new Singleton 时指令重排序导致其他线程获取到未初始化完的对象。instance = new Singleton() 这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。1.给 instance 分配内存2.调用 Singleton 的构造函数来初始化成员变量3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）
但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错。

讲讲 synchronized 和 volatile 的区别

synchronized(不做过多解释)

同步块大家都比较熟悉，通过 synchronized 关键字来实现，所有加上synchronized 和 块语句，在多线程访问的时候，同一时刻只能有一个线程能够用

synchronized 修饰的方法 或者 代码块。

volatile

用 volatile 修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile很容易被误用，用来进行原子性操作。

一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义： 
  
  1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是
立即可见的。 
  
  2）禁止进行指令重排序。 
  
volatile 本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； 
synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。  
1. volatile 仅能使用在变量级别； 
synchronized 则可以使用在变量、方法、和类级别的  
2. volatile 仅能实现变量的修改可见性，并不能保证原子性； 
synchronized 则可以保证变量的修改可见性和原子性  
3. volatile 不会造成线程的阻塞； 
synchronized 可能会造成线程的阻塞。  
4. volatile 标记的变量不会被编译器优化； 
synchronized 标记的变量可以被编译器优化

### 7、静态内部类 [推荐用]

```java
public class Singleton{
    
	private Singleton() {}
	
	private static class SingletonHolder{
		private static Singleton instance = new Singleton();
	} 
	
	public static Singleton getInstance(){
		return SingletonHolder.instance;
	}
}
```


这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要 Singleton 类被装载就会实例化，没有 Lazy-Loading 的作用，而静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。

类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。

优点：避免了线程不安全，延迟加载，效率高。

### 8、枚举 [推荐用]

```java
public enum SingletonEnum {
    
     INSTANCE; 
     
     public void method(){
     }
}

// 访问方式
// SingletonEnum.INSTANCE.method();
```

默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。同时他也是《Effective Java》中推荐的模式。最后通过枚举类，他能自动避免序列化/反序列化攻击，以及反射攻击(枚举类不能通过反射生成)。

# 单例模式总结
## 优点

系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。

## 缺点

当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。

## 适用场合

- 需要频繁的进行创建和销毁的对象；
- 创建对象时耗时过多或耗费资源过多，但又经常用到的对象；
- 工具类对象；
- 频繁访问数据库或文件的对象。
