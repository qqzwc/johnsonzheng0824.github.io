---
layout: post
title: "《Java 秒杀系统方案优化 高性能高并发实战》笔记"
date: 2018-06-10
tag: 高并发
---  

## spring-boot

这个项目是基于 spring-boot 来做的，教了如何打包成 jar 包和 war 包，spring-boot 内置了 tomcat，一个 spring-boot 项目运行起来非常方便。

## 数据校验

JSR-303 是一个数据验证的规范，引入依赖 spring-boot-starter-validation，就可以在后台做各种数据校验，还可以自定义验证器。项目中定义了一个验证器 IsMobile，验证是不是一个合法的手机号。

## 封装

这个项目中一些代码的封装方法值得学习，用类 com.imooc.miaosha.result.Result 统一封装 json 接口数据。
异常类 com.imooc.miaosha.exception.GlobalException 和 com.imooc.miaosha.exception.GlobalExceptionHandler 统一处理各种异常情形，从而接口总是能返回 json 串。
统一异常处理可以参考：[Controller 层方法，进行统一异常处理](https://www.cnblogs.com/ssslinppp/p/7606038.html)
有两种解决方案：通知控制器 @ControllerAdvice 或者使用 AOP。项目中用的是通知控制器。
项目中 GlobalExceptionHandler 类定义了异常处理逻辑，对类加了注解：

```
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {}
```

很多博客里说用 @RestControllerAdvice 注解，这样就可以不用加 @ResponseBody 了。
@RestControllerAdvice 和 @ControllerAdvice 的区别见：

1.  [Annotation Type RestControllerAdvice](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestControllerAdvice.html)
2.  [@RestControllerAdvice vs @ControllerAdvice](https://stackoverflow.com/questions/43124391/restcontrolleradvice-vs-controlleradvice/43124517)

@RestControllerAdvice：

```
A convenience annotation that is itself annotated with @ControllerAdvice and @ResponseBody.
```

## redis

见识了 redis 的强大之处，项目里封装了一个用 redis 存取对象的方法，先用 com.alibaba.fastjson.JSON 将对象序列化成 json 字符串，然后将 json 字符串存在 redis 中。<br>
redis 缓存可以设置过期时间，利用这一特性，项目中有多处应用：图片验证码可以用 redis 缓存，一定时间后失效；用户登录 session 可以保存在 redis 中，一段时间后失效；接口限流防刷，例如一个用户 1 分钟内对同一个接口的请求不能超过 100 次。项目中讲了很多页面优化的方法，其中很多方法是用到了 redis，例如页面缓存，对象缓存等。

## 分布式 session

将登录用户的信息保存在 redis 中，实现分布式 session。<br>
用户登录时，生成一个 uuid，作为 redis 的 key，value 是用户信息，并且将这个 key 放在 cookie 中，然后 response.addCookie(cookie)，把 cookie 返回给浏览器。<br>
拦截器中，在控制器请求处理前，会从 redis 中取到用户信息，key 从哪里来的呢，一个 http 请求会在 cookie 或者请求参数中带上前面的 key。

## JMeter

使用 JMeter 进行压测

## 消息队列

之前学过 activemq，这里又学习了一下 rabbitmq。<br>
秒杀操作的逻辑是先在 redis 中预减库存，然后再去操作数据库。<br>
为了减轻 redis 的压力，用本地 HashMap 保存了可秒杀商品的剩余数量，相当于对库存做了个内存标记。<br>
操作数据库也是不是直接同步去访问，而是使用了消息列队异步访问，把一条秒杀请求放入消息队列，然后再慢慢处理。<br>
rabbitmq 有四种交换机模式：Direct 模式、Topic 模式、Fanout 模式、Header 模式。
项目中用的是最简单的 Direct 模式。

## 拦截器

拦截器 com.imooc.miaosha.access.AccessInterceptor，接口方法真正的业务逻辑之前常有些共同的逻辑，比如判断用户是否登录，以及对接口的限流防刷控制，可以一并放在拦截器中。<br>
项目用的是 spring-boot，不用写各种 xml 配置文件了，拦截器在类 com.imooc.miaosha.config.WebConfig 中进行注册。

```
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter{}
```

如果在处理接口跨域问题，也是在这个类中进行配置，类 WebMvcConfigurerAdapter 中有抽象方法 public void addCorsMappings(CorsRegistry registry) {}，实现一下就可以了。

## 静态分离

java web 项目中前端页面的展示，以及用得比较多的是返回一个 jsp，后台控制器方法绑定参数，把 jsp 渲染好后返回给前台。现在主流的做法是，前端用纯 html 编写，后台返回 json 串，前台用异步请求到 json 格式的接口数据，然后填充到 html 中。这就是静态分离。<br>
两种前后端搭配方式：<br>
前后端分离，后端提供 json 接口就行了，这是现在的主流做法<br>
前端使用 jsp 等模板技术，后端返回填充数据。使用模板会带来性能损耗，现在不推荐这种做法了。

此外还有关于加盐加密、图形验证码等知识。

## 秒杀流程

1.  秒杀活动开始之前有个活动倒计时，时间到了则会放开秒杀的权限，并生成一个验证码展示在前面页面，并把验证结果存在 redis 中，这里利用 redis 有过期时间的特性，也给验证码的缓存加了个过期时间。这里的 redis 缓存用的是 redis 的 string 类型。
2.  在秒杀之前先要填一个验证码 verifyCode，点击秒杀按钮时，先发送 ajax 请求到后台获取真实的秒杀地址 path，这里秒杀地址是隐藏的，目的是防止有人恶意刷秒杀接口。所谓隐藏地址，其实是在请求地址中加一段随机字符串，这段字符串是变化的，因此秒杀请求地址是动态的；
3.  先说下如何获取真实的秒杀地址，后台先访问 redis，验证一下这个验证码有没有过期以及这个 verifyCode 是不是正确，验证码验证通过后，先删除这个验证码缓存，然后生成真实地址；
4.  真实地址随机字符串由 uuid 以及 md5 加密生成，并且保存在 redis 中，并且设置了有效期；
5.  从浏览器端向秒杀地址发起请求，带上 path 参数去后台调用真正的秒杀接口，下面是秒杀接口的逻辑；
6.  访问 redis，验证 path 有没有过期，以及是不是正确。这里验证 path 以及上面的校验验证码，都是用 userId 对应生成的一个 key 值去取 redis 中的数据；
7.  path 验证通过后，先访问内存标识，看秒杀的这个商品有没有卖完。每一种参与秒杀活动的商品都在内存里用 HashMap 设置了一个标识，标识某个商品 id 商品是否卖完了。这里的是否卖完的内存标识设置以及每种参与秒杀商品的库存存入 redis 是在系统启动时做的；
8.  如果内存标识中这个商品没有卖完，则要看这个用户在这次活动中是否已经秒杀到过这种商品，因为我们的秒杀规则是一个用户 id 对于某个商品 id 的商品只能秒杀一件。如何判断该用户有没有秒杀过这件商品呢，秒杀记录也保存在 redis 缓存中；
9.  如果判断秒杀过则返回提示，如果没有秒杀过，继续；
10.  上面说过系统加载时 redis 中保存了各商品对应的库存，这里用到 redis 的原子操作的方法 decr，将对应商品的库存减 1，此时数据库时的库存还没有减，因此是预减库存；
11.  desc 方法返回该商品此时的库存，如果小于 0，说明商品已经卖完了，此次秒杀无效，并且设置该商品的内存标识为 true，表示已卖完；
12.  正确地预减库存后，然后就要真正操作数据库了，数据库一般是性能瓶颈，比较耗时，因此决定用异步方式处理。对于每一条秒杀请求存入消息队列 RabbitMQ 中，消息体中要包含哪个用户秒杀哪个商品的信息，这里是封装了一个消息体类，这样一个秒杀请求就进入了消息队列，一个秒杀请求还没有完成，真正的秒杀请求的完成得要持久化到数据库，生成订单，减了数据库的库存才能算数，这时在客户端显示的一般是排队中，比如以前在抢购小米手机时，我就看到这样的展示，过一会再刷新页面就显示没抢到；
13.  消息队列处理秒杀请求。先从消息体中解析出用户 id 和商品 id，查数据库看这个商品是否卖完了，查数据库看该用户对于这个商品是否有过秒杀记录；
14.  数据库减库存，数据库生成订单，这两项持久化地写数据库操作放在同一个事务中，要么都执行成功，要么都失败。其中生成订单又是另外一个事务中，在这个生成订单事务中，会分别在订单表、秒杀订单表生成一条记录，并把秒杀记录对象，包括秒杀单号、订单号、用户 id、商品 id，存入 redis 中。如果数据库减库存失败，表明商品卖完了，则要在 redis 中设置该商品已卖完的标识。spring 项目中使用事务，只用在相应的方法前面加个注解 @Transactional，那么这个方法里的操作都在一个事务里了；
15.  ajax 发起秒杀请求，秒杀请求的处理逻辑最后也只是把这条请求放入消息队列，并不能返回是否秒杀成功的结果。因此，当秒杀请求正确响应后，即请求放入消息队列后，需要另外一个请求去轮询秒杀结果，秒杀成功的标志是生成秒杀订单，并把秒杀订单对象放入 redis 中。所以轮询秒杀结果，只用去轮询 redis 中是否有对应于该用户的该商品的秒杀订单对象，如果有，则表明秒杀成功，并在前台给出提示。

上面的秒杀流程对应的流程图如下：
步骤 1 到 12，主体是 redis 预减库存，生成消息队列：

![](/images/posts/gaobingfa/1.png)

步骤 13 到 14 是处理消息队列：

![](/images/posts/gaobingfa/2.png)


步骤 15，是客户端请求秒杀结果：

![](/images/posts/gaobingfa/3.png)


秒杀场景是从客户端的 ajax 请求发起的，上面 15 个步骤可以用下面的 js 串起来：

```
/秒杀按钮触发下面的js方法
function getMiaoshaPath(){
    var goodsId = $("#goodsId").val();
    g_showLoading();
    $.ajax({
        url:"/miaosha/path",
        type:"GET",
        data:{
            goodsId:goodsId,
            verifyCode:$("#verifyCode").val()
        },
        success:function(data){
            if(data.code == 0){
                var path = data.data;
                //获取到秒杀地址后，发起秒杀请求
                doMiaosha(path);
            }else{
                layer.msg(data.msg);
            }
        },
        error:function(){
            layer.msg("客户端请求有误");
        }
    });
}
//发起秒杀请求
function doMiaosha(path){
    $.ajax({
        url:"/miaosha/"+path+"/do_miaosha",
        type:"POST",
        data:{
            goodsId:$("#goodsId").val()
        },
        success:function(data){
            if(data.code == 0){
                //获取秒杀结果
                getMiaoshaResult($("#goodsId").val());
            }else{
                layer.msg(data.msg);
            }
        },
        error:function(){
            layer.msg("客户端请求有误");
        }
    }); 
}
//获取秒杀结果
function getMiaoshaResult(goodsId){
    g_showLoading();
    $.ajax({
        url:"/miaosha/result",
        type:"GET",
        data:{
            goodsId:$("#goodsId").val(),
        },
        success:function(data){
            if(data.code == 0){
                var result = data.data;
                if(result < 0){
                    layer.msg("对不起，秒杀失败");
                }else if(result == 0){//继续轮询
                    setTimeout(function(){
                        getMiaoshaResult(goodsId);
                    }, 200);
                }else{
                    layer.confirm("恭喜你，秒杀成功！查看订单？", {btn:["确定","取消"]},
                            function(){
                                window.location.href="/order_detail.htm?orderId="+result;
                            },
                            function(){
                                layer.closeAll();
                            });
                }
            }else{
                layer.msg(data.msg);
            }
        },
        error:function(){
            layer.msg("客户端请求有误");
        }
    });
}
```

### 内存标记的分布式一致性

上面采用内存标记的方式，本地 hashmap 变量，如果分布式场景，多份内存标记，如何实现分布式一致性？
两种常用办法：

1.  所有的进程去访问一个共享内存，这个共享内存是虚拟的。
2.  每一个机器都有一个存储内容的本地副本，读取操作我们可以从本地内存进行读取，写入操作我们可以现在本地下入之后，再通过广播向其他的内存块发送 update 消息。